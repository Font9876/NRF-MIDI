diff --git a/16.6_ESB_IMMEDIATE/16.6_ESB_IMMEDIATE.ino b/16.6_ESB_IMMEDIATE/16.6_ESB_IMMEDIATE.ino
index 6ff51d7187f8d64f7873d9caa57a22d838a954c2..7f6025263d949bdefd9a55024f194b66ea4aec09 100644
--- a/16.6_ESB_IMMEDIATE/16.6_ESB_IMMEDIATE.ino
+++ b/16.6_ESB_IMMEDIATE/16.6_ESB_IMMEDIATE.ino
@@ -1,50 +1,63 @@
 #include <Arduino.h>
 #include "Adafruit_TinyUSB.h"
 #include "nrf_to_nrf.h"
 #include <Adafruit_GFX.h>
 #include <Adafruit_ST7789.h>
 #include <SPI.h>
 #include "InternalFileSystem.h"
 #include "flash/flash_nrf5x.h"
 #include "variant.h"
 #include "nrf_power.h"
 #include "nrf_gpio.h"
 #include "nrf_uart.h"
 #include "nrf_twi.h"
 #include "nrf_spi.h"
 #include <stdarg.h>
 #include <math.h>
 #include <algorithm>
 #include "nrf_radio.h"
 #include <bluefruit.h>
 #include <avr/pgmspace.h>
 
 // --- WebUSB Configuration ---
 Adafruit_USBD_WebUSB webusb;
 WEBUSB_URL_DEF(landingPage, 1, "diningwork.space/"); // Change to your desired URL
 
+#define ESB_BRIDGE_MAGIC 0xFA
+#define ESB_BRIDGE_PAYLOAD_SIZE 28
+#define ESB_BRIDGE_POLL_INTERVAL_MS 10
+#define ESB_BRIDGE_LISTEN_WINDOW_MS 3
+
+struct EsbBridgePacket {
+    uint8_t magic;
+    uint8_t msgId;
+    uint8_t chunkIndex;
+    uint8_t totalChunks;
+    char payload[ESB_BRIDGE_PAYLOAD_SIZE];
+};
+
 #define TFT_CS 11
 #define TFT_DC 12
 #define TFT_RST 20
 #define TFT_MOSI 19
 #define TFT_SCK 18
 #define TFT_BL 10
 
 #define THEME_BG 0xFFFF
 #define THEME_FG 0x0000
 #define THEME_ACCENT 0x0000
 #define THEME_INACTIVE 0xC618
 #define THEME_INDICATOR_ON 0x0000
 #define THEME_INDICATOR_OFF 0xFFFF
 
 SPIClass customSPI(NRF_SPIM3, -1, TFT_SCK, TFT_MOSI);
 Adafruit_ST7789 tft = Adafruit_ST7789(&customSPI, TFT_CS, TFT_DC, TFT_RST);
 
 const int16_t SCREEN_WIDTH = 240;
 const int16_t SCREEN_HEIGHT = 280;
 
 Adafruit_USBD_MIDI usb_midi;
 nrf_to_nrf nrf;
 
 BLEDfu bledfu;
 BLEDis bledis;
@@ -295,86 +308,184 @@ void handleSetupInput();
 void sendCC(uint8_t cc, uint8_t value);
 void sendPotCC(uint8_t potIndex, uint8_t value);
 void resetRadio();
 void idleRadioCheck();
 void enterSystemOff(ShutdownReason reason = NORMAL);
 void selectChannel(int channel);
 int readMedianADC(int analogPin);
 void blinkAssignedInputLabelAndIndicator();
 void clearBlinkingArea(uint8_t inputIndex, bool isCCAssignmentMode);
 void drawFooterInstructions(const __FlashStringHelper* text);
 void drawActionFooter(const __FlashStringHelper* left, const __FlashStringHelper* center, const __FlashStringHelper* right);
 void drawDeviceSetupMenu();
 void drawBluetoothMenu();
 void partialRedrawBluetoothMenu(uint8_t oldCursor, uint8_t newCursor);
 void handleScreenFade();
 void line_state_callback(bool connected);
 void startBLE();
 void stopBLE();
 void drawBleConnectionStatus();
 void performEsbSweep();
 void drawEsbSweepScreen(uint8_t channel, uint8_t sample, uint8_t acks, bool initial);
 void drawEsbConnectMenu();
 void partialRedrawEsbConnectMenu(uint8_t oldCursor, uint8_t newCursor);
 
 // --- WebUSB Functions ---
-void sendSettingsToWeb() {
-    if (!webusb.connected()) return;
+String buildSettingsJson() {
     String json = "{";
     json += "\"activeBank\":" + String(globalSettings.activeBank) + ",";
     json += "\"brightness\":" + String(globalSettings.brightness) + ",";
     json += "\"midiChannel\":" + String(currentBankSettings.midiChannel) + ",";
     json += "\"buttonMode\":" + String(currentBankSettings.buttonMode) + ",";
     json += "\"esbChannel\":" + String(globalSettings.esbChannel) + ",";
     json += "\"bleOn\":" + String(bleRunning ? "true" : "false") + ",";
     json += "\"blePeerName\":\"" + String(blePeerName) + "\",";
     json += "\"labels\":[";
     for (int i = 0; i < TOTAL_ASSIGNABLE_INPUTS; i++) {
         json += "\"";
         if (i < NUM_ANALOG_POTS) { json += currentBankSettings.potLabels[i]; }
         else { json += currentBankSettings.buttonLabels[i - NUM_ANALOG_POTS]; }
         json += "\"";
         if (i < TOTAL_ASSIGNABLE_INPUTS - 1) json += ",";
     }
     json += "],";
     json += "\"ccs\":[";
     for (int i = 0; i < TOTAL_ASSIGNABLE_INPUTS; i++) {
         json += String(currentBankSettings.assignableCCs[i]);
         if (i < TOTAL_ASSIGNABLE_INPUTS - 1) json += ",";
     }
     json += "],";
     json += "\"currentPotValues\":[";
     for (int i = 0; i < NUM_ANALOG_POTS; i++) {
         json += String(lastSentCCValue[i]);
         if (i < NUM_ANALOG_POTS - 1) json += ",";
     }
     json += "]";
-    json += "}\n";
+    json += "}";
+    return json;
+}
+
+void sendSettingsToWeb() {
+    if (!webusb.connected()) return;
+    String json = buildSettingsJson();
+    json += "\n";
     webusb.print(json);
     webusb.flush();
 }
 
+bool processCommandString(const String& command, bool allowWebNotifications) {
+    bool shouldSendSettings = false;
+
+    if (command.equals("get_settings")) {
+        shouldSendSettings = true;
+    } else if (command.startsWith("set_brightness=")) {
+        int brightness_8bit = command.substring(15).toInt();
+        brightness_8bit = constrain(brightness_8bit, 3, 255);
+
+        if (globalSettings.brightness != brightness_8bit) {
+            brightnessBeforeFade_14bit = currentBrightness_14bit;
+            globalSettings.brightness = brightness_8bit;
+            screenState = FADING_UP;
+            fadeStartTime = micros();
+        }
+        shouldSendSettings = true;
+    } else if (command.startsWith("set_midi_ch=")) {
+        int channel = command.substring(12).toInt();
+        currentBankSettings.midiChannel = constrain(channel, 1, 16);
+        shouldSendSettings = true;
+    } else if (command.startsWith("set_cc=")) {
+        int firstComma = command.indexOf(',');
+        int index = command.substring(7, firstComma).toInt();
+        int value = command.substring(firstComma + 1).toInt();
+        if (index >= 0 && index < TOTAL_ASSIGNABLE_INPUTS) {
+            currentBankSettings.assignableCCs[index] = constrain(value, 0, 127);
+            saveCurrentBankSettings();
+            shouldSendSettings = true;
+        }
+    } else if (command.startsWith("set_label=")) {
+        int firstComma = command.indexOf(',');
+        int index = command.substring(10, firstComma).toInt();
+        String label = command.substring(firstComma + 1);
+        if (index >= 0 && index < TOTAL_ASSIGNABLE_INPUTS) {
+            if (index < NUM_ANALOG_POTS) {
+                strncpy(currentBankSettings.potLabels[index], label.c_str(), POT_LABEL_LENGTH);
+                currentBankSettings.potLabels[index][POT_LABEL_LENGTH] = '\0';
+            } else {
+                strncpy(currentBankSettings.buttonLabels[index - NUM_ANALOG_POTS], label.c_str(), POT_LABEL_LENGTH);
+                currentBankSettings.buttonLabels[index - NUM_ANALOG_POTS][POT_LABEL_LENGTH] = '\0';
+            }
+            saveCurrentBankSettings();
+            forceFullRedraw = true;
+            shouldSendSettings = true;
+        }
+    } else if (command.startsWith("set_bank=")) {
+        int bank = command.substring(9).toInt();
+        if (bank >= 0 && bank < NUM_BANKS) {
+            globalSettings.activeBank = bank;
+            saveGlobalSettings();
+            loadSettings();
+            activeMidiSettings = &currentBankSettings;
+            updateMainScreenLabelsOnly(currentBankSettings, false);
+            forceFullRedraw = true;
+            if (allowWebNotifications && webusb.connected()) {
+                webusb.print("bank_changed:" + String(globalSettings.activeBank) + "\n");
+                webusb.flush();
+            }
+            shouldSendSettings = true;
+        }
+    } else if (command.startsWith("set_button_mode=")) {
+        int mode = command.substring(16).toInt();
+        currentBankSettings.buttonMode = constrain(mode, 0, 1);
+        saveCurrentBankSettings();
+        shouldSendSettings = true;
+    } else if (command.startsWith("set_esb_ch=")) {
+        int esb_ch = command.substring(11).toInt();
+        globalSettings.esbChannel = esb_ch;
+        saveGlobalSettings();
+        resetRadio();
+        shouldSendSettings = true;
+    } else if (command.equals("toggle_ble")) {
+        if (allowWebNotifications) {
+            if (bleRunning) {
+                stopBLE();
+            } else {
+                startBLE();
+            }
+        }
+        shouldSendSettings = true;
+    } else if (command.equals("start_cal")) {
+        currentAppMode = SETUP_MENU;
+        currentSetupSubMode = CALIBRATION_MAIN;
+        menuCursor = 1;
+        subMenuCursor = 1;
+        drawCalibrationMenu();
+        setupStartTime = millis();
+    }
+
+    return shouldSendSettings;
+}
+
 void setBacklight(uint16_t value) {
   currentBrightness_14bit = constrain(value, 0, BRIGHTNESS_MAX_14BIT);
   analogWrite(TFT_BL, currentBrightness_14bit);
 }
 
 void drawEsbSweepScreen(uint8_t channel, uint8_t sample, uint8_t acks, bool initial) {
     if (!tftConnected) return;
 
     // Static variables to track the last drawn state to avoid unnecessary redraws.
     static uint8_t last_acks = 255;
     static int last_progress_w = -1;
 
     // When a new channel scan starts (`initial` is true)
     if (initial) {
         // Reset per-channel trackers
         last_acks = 0; 
         last_progress_w = 0;
 
         tft.startWrite();
         tft.setFont(NULL);
         tft.setTextSize(1.8);
         tft.setTextColor(THEME_FG);
         
         // Clear area for channel number and draw the new one
         tft.fillRect(120, 78, 80, 20, THEME_BG); 
@@ -575,126 +686,58 @@ void performEsbSweep() {
             menuCursor = 0;
             drawEsbConnectMenu();
             sweepChannelIndex = 0;
             isFirstScanOfSweep = true; // ADDED: Reset the flag when the sweep is done
             resetRadio(); // This will revert retries back to (0, 5)
             setupStartTime = millis(); // FIX: Reset setup timeout timer
         }
     }
 }
 
 void handleWebUSBCommands() {
     static bool requestStartBle = false;
     static unsigned long startBleDelayTime = 0;
     const unsigned long BLE_START_DELAY_MS = 1;
 
     if (requestStartBle && millis() - startBleDelayTime >= BLE_START_DELAY_MS) {
         requestStartBle = false;
         startBLE();
         return;
     }
 
     if (webusb.available()) {
         String command = webusb.readStringUntil('\n');
         command.trim();
 
-        if (command.equals("get_settings")) {
+        if (command.equals("toggle_ble") && !bleRunning) {
+            requestStartBle = true;
+            startBleDelayTime = millis();
+            return;
+        }
+
+        if (processCommandString(command, true)) {
             sendSettingsToWeb();
-        } else if (command.startsWith("set_brightness=")) {
-            int brightness_8bit = command.substring(15).toInt();
-            brightness_8bit = constrain(brightness_8bit, 3, 255);
-
-            if (globalSettings.brightness != brightness_8bit) {
-                brightnessBeforeFade_14bit = currentBrightness_14bit;
-                globalSettings.brightness = brightness_8bit;
-                screenState = FADING_UP;
-                fadeStartTime = micros();
-            }
-        } else if (command.startsWith("set_midi_ch=")) {
-            int channel = command.substring(12).toInt();
-            currentBankSettings.midiChannel = constrain(channel, 1, 16);
-        } else if (command.startsWith("set_cc=")) {
-            int firstComma = command.indexOf(',');
-            int index = command.substring(7, firstComma).toInt();
-            int value = command.substring(firstComma + 1).toInt();
-            if (index >= 0 && index < TOTAL_ASSIGNABLE_INPUTS) {
-                currentBankSettings.assignableCCs[index] = constrain(value, 0, 127);
-                saveCurrentBankSettings();
-            }
-        } else if (command.startsWith("set_label=")) {
-            int firstComma = command.indexOf(',');
-            int index = command.substring(10, firstComma).toInt();
-            String label = command.substring(firstComma + 1);
-            if (index >= 0 && index < TOTAL_ASSIGNABLE_INPUTS) {
-                if (index < NUM_ANALOG_POTS) {
-                    strncpy(currentBankSettings.potLabels[index], label.c_str(), POT_LABEL_LENGTH);
-                    currentBankSettings.potLabels[index][POT_LABEL_LENGTH] = '\0';
-                } else {
-                    strncpy(currentBankSettings.buttonLabels[index - NUM_ANALOG_POTS], label.c_str(), POT_LABEL_LENGTH);
-                    currentBankSettings.buttonLabels[index - NUM_ANALOG_POTS][POT_LABEL_LENGTH] = '\0';
-                }
-                saveCurrentBankSettings();
-                forceFullRedraw = true;
-            }
-        } else if (command.startsWith("set_bank=")) {
-            int bank = command.substring(9).toInt();
-            if (bank >= 0 && bank < NUM_BANKS) {
-                globalSettings.activeBank = bank;
-                saveGlobalSettings();
-                loadSettings();
-                activeMidiSettings = &currentBankSettings;
-                updateMainScreenLabelsOnly(currentBankSettings, false);
-                forceFullRedraw = true;
-                if (webusb.connected()) {
-                    webusb.print("bank_changed:" + String(globalSettings.activeBank) + "\n");
-                    webusb.flush();
-                }
-                sendSettingsToWeb();
-            }
-        } else if (command.startsWith("set_button_mode=")) {
-            int mode = command.substring(16).toInt();
-            currentBankSettings.buttonMode = constrain(mode, 0, 1);
-            saveCurrentBankSettings();
-        } else if (command.startsWith("set_esb_ch=")) {
-            int esb_ch = command.substring(11).toInt();
-            globalSettings.esbChannel = esb_ch;
-            saveGlobalSettings();
-            resetRadio();
-        } else if (command.equals("toggle_ble")) {
-            if (bleRunning) {
-                stopBLE();
-            } else {
-                requestStartBle = true;
-                startBleDelayTime = millis();
-            }
-        } else if (command.equals("start_cal")) {
-            currentAppMode = SETUP_MENU;
-            currentSetupSubMode = CALIBRATION_MAIN;
-            menuCursor = 1;
-            subMenuCursor = 1;
-            drawCalibrationMenu();
-            setupStartTime = millis();
         }
     }
 }
 
 void line_state_callback(bool connected) {}
 
 void connect_callback(uint16_t conn_handle) {
     connHandle = conn_handle;
     BLEConnection* conn = Bluefruit.Connection(conn_handle);
     if (conn) {
         conn->getPeerName(blePeerName, sizeof(blePeerName));
         conn->requestConnectionParameter(6, 0, 500);
     }
     forceFullRedraw = true;
     sendSettingsToWeb();
 }
 
 void disconnect_callback(uint16_t conn_handle, uint8_t reason) {
     connHandle = BLE_CONN_HANDLE_INVALID;
     memset(blePeerName, 0, sizeof(blePeerName));
     forceFullRedraw = true;
     sendSettingsToWeb();
 }
 
 void startBLE() {
@@ -1299,64 +1342,152 @@ void updatePotVisual(uint8_t potIndex, uint8_t newCCValue, const BankSettings& s
         if (newFillHeight > oldFillHeight) {
             int diffHeight = newFillHeight - oldFillHeight;
             int yPos = bar_y_start + (barMaxHeight - newFillHeight);
             tft.fillRect(barX, yPos, barWidth, diffHeight, THEME_FG);
         } else if (newFillHeight < oldFillHeight) {
             int diffHeight = oldFillHeight - newFillHeight;
             int yPos = bar_y_start + (barMaxHeight - oldFillHeight);
             tft.fillRect(barX, yPos, barWidth, diffHeight, THEME_INACTIVE);
         }
         lastRawValueForDisplay[potIndex] = newRawValueApprox;
     }
     tft.endWrite();
 }
 
 void resetRadio() {
     // Power down the radio if it's currently active to ensure settings are applied.
     if (radioActive) {
         nrf.powerDown();
     }
     // Re-initialize the radio with the current global settings.
     nrf.begin(); 
     nrf.setPALevel(NRF_PA_MAX);
     nrf_radio_txpower_set(NRF_RADIO, NRF_RADIO_TXPOWER_POS8DBM);
     nrf.setAutoAck(true); 
     nrf.setRetries(0, 5); // Set standard retries
+    nrf.enableDynamicPayloads(32);
     nrf.setChannel(globalSettings.esbChannel); // Apply the ESB channel from global settings
     nrf.stopListening(); 
     
     // Mark the radio as active and update the last activity timestamp.
     radioActive = true;
     lastRadioActivityTime = millis();
 }
 
 void idleRadioCheck() {
     if (radioActive && millis() - lastRadioActivityTime > NRF_IDLE_TIMEOUT_MS) {
         nrf.powerDown(); radioActive = false;
     }
 }
 
+void sendEsbBridgeResponse(uint8_t msgId, const String& response) {
+    int totalChunks = (response.length() + ESB_BRIDGE_PAYLOAD_SIZE - 1) / ESB_BRIDGE_PAYLOAD_SIZE;
+    if (totalChunks == 0) totalChunks = 1;
+
+    for (int chunkIndex = 0; chunkIndex < totalChunks; chunkIndex++) {
+        EsbBridgePacket packet = {};
+        packet.magic = ESB_BRIDGE_MAGIC;
+        packet.msgId = msgId;
+        packet.chunkIndex = chunkIndex;
+        packet.totalChunks = totalChunks;
+
+        int startIndex = chunkIndex * ESB_BRIDGE_PAYLOAD_SIZE;
+        int chunkLength = min(ESB_BRIDGE_PAYLOAD_SIZE, response.length() - startIndex);
+        for (int i = 0; i < chunkLength; i++) {
+            packet.payload[i] = response[startIndex + i];
+        }
+
+        nrf.stopListening();
+        nrf.write(&packet, 4 + chunkLength);
+        delayMicroseconds(200);
+    }
+}
+
+void handleEsbBridgeCommands() {
+    static unsigned long lastPollTime = 0;
+    if (!radioActive) {
+        resetRadio();
+    }
+
+    unsigned long currentTime = millis();
+    if (currentTime - lastPollTime < ESB_BRIDGE_POLL_INTERVAL_MS) {
+        return;
+    }
+    lastPollTime = currentTime;
+
+    nrf.startListening();
+    unsigned long startTime = millis();
+    while (millis() - startTime < ESB_BRIDGE_LISTEN_WINDOW_MS) {
+        if (!nrf.available()) {
+            continue;
+        }
+
+        uint8_t bytes = nrf.getDynamicPayloadSize();
+        if (bytes < 4) {
+            uint8_t discard[32];
+            nrf.read(discard, min(bytes, uint8_t(sizeof(discard))));
+            continue;
+        }
+
+        EsbBridgePacket packet = {};
+        if (bytes > sizeof(packet)) bytes = sizeof(packet);
+        nrf.read(&packet, bytes);
+        if (packet.magic != ESB_BRIDGE_MAGIC) {
+            continue;
+        }
+
+        String command = "";
+        uint8_t payloadLength = bytes - 4;
+        for (uint8_t i = 0; i < payloadLength; i++) {
+            command += packet.payload[i];
+        }
+        command.trim();
+
+        if (command.equals("toggle_ble")) {
+            bool desiredBleState = !bleRunning;
+            bool originalBleState = bleRunning;
+            bleRunning = desiredBleState;
+            String response = buildSettingsJson();
+            bleRunning = originalBleState;
+            sendEsbBridgeResponse(packet.msgId, response);
+            lastRadioActivityTime = millis();
+            if (desiredBleState) {
+                startBLE();
+            } else {
+                stopBLE();
+            }
+        } else {
+            bool shouldSendSettings = processCommandString(command, false);
+            String response = shouldSendSettings ? buildSettingsJson() : String("ok");
+            sendEsbBridgeResponse(packet.msgId, response);
+            lastRadioActivityTime = millis();
+        }
+        break;
+    }
+    nrf.stopListening();
+}
+
 void handleScreenFade() {
     // Static variable to track the screen state from the previous call.
     static ScreenState lastScreenState = screenState;
     // Static variable to store the brightness at the moment a fade begins.
     static uint16_t fadeStartBrightness_14bit = 0;
 
     // If a new fade sequence is starting, capture the current brightness.
     if (screenState != lastScreenState &&
         (screenState == FADING_UP || screenState == FADING_DOWN || screenState == FADING_REVERT)) {
         fadeStartBrightness_14bit = currentBrightness_14bit;
     }
 
     // If not fading, there's nothing to do. Update state and exit.
     if (screenState == BRIGHT || screenState == DIM) {
         lastScreenState = screenState;
         return;
     }
 
     unsigned long currentTimeUs = micros();
     unsigned long elapsedTime = currentTimeUs - fadeStartTime;
     uint16_t targetBrightness_14bit = map(globalSettings.brightness, 3, 255, BRIGHTNESS_MIN_14BIT, BRIGHTNESS_MAX_14BIT);
 
     if (elapsedTime >= FADE_DURATION_US) {
         // Fade is complete, snap to the final value.
         if (screenState == FADING_DOWN) {
@@ -3747,50 +3878,51 @@ void setup() {
         // This initial fade is temporary for the low battery warning, so direct analogWrite is ok.
         uint16_t targetBrightness_14bit = map(globalSettings.brightness, 3, 255, BRIGHTNESS_MIN_14BIT, BRIGHTNESS_MAX_14BIT);
         if (targetBrightness_14bit < BRIGHTNESS_MIN_14BIT) targetBrightness_14bit = BRIGHTNESS_MIN_14BIT;
         unsigned long fadeSetupStartTime = micros();
         while(micros() - fadeSetupStartTime < FADE_DURATION_US) {
             float progress = (float)(micros() - fadeSetupStartTime) / FADE_DURATION_US;
             uint16_t currentBrightness = mapFloat(progress, 0.0, 1.0, 0, targetBrightness_14bit);
             analogWrite(TFT_BL, currentBrightness);
             // Direct write is fine here
         }
         analogWrite(TFT_BL, targetBrightness_14bit);
         // Direct write is fine here
         enterSystemOff(WAKE_LOW_BATTERY);
     }
 
     drawMainScreenPotentiometerLayout(currentBankSettings, false);
     redrawAllPotValues(currentBankSettings);
     forceFullRedraw = true;
     drawTopStatusBar(TinyUSBDevice.mounted(), false, 0, 0, false);
     forceFullRedraw = false;
     fadeStartTime = micros();
 }
 
 void loop() {
     handleWebUSBCommands();
+    handleEsbBridgeCommands();
     handleScreenFade();
 
     unsigned long currentTime = millis();
 
     // D0 button, USB, and battery logic
     bool d0_isPressed_now = !digitalRead(0);
     bool currentUSB = TinyUSBDevice.mounted();
     if (currentUSB) {
         isAwaitingPostUnplugShutdown = false;
         if (currentTime - lastMidiActivityTime > AUTO_SYSTEM_OFF_TIMEOUT_MS) { wasPluggedInLong = true; }
     }
 
     if (lastUSBState && !currentUSB) {
         webusb.disconnect(); 
         if (wasPluggedInLong) { isAwaitingPostUnplugShutdown = true; lastMidiActivityTime = currentTime; wasPluggedInLong = false; }
         lastBatterySampleTime = currentTime;
         analogOversampling(256);
         long rawSum = 0;
         for (int i = 0; i < BATTERY_SAMPLE_COUNT ; i++) { rawSum += BATT_PIN_READ; delayMicroseconds(50); }
         float adc_buf_avg = (float)rawSum / BATTERY_SAMPLE_COUNT;
         
         // --- FIX START ---
         // Restored the correct, more robust battery voltage calculation formula.
         averagedBatteryVoltage = (adc_buf_avg / VBAT_ADC_RES) * VBAT_REF_VOLTAGE * VBAT_GAIN_DIVIDER * VBAT_CORRECTION_FACTOR; 
         // --- FIX END ---
