diff --git a/1.0.4.html b/1.0.4.html
index 7ce570e6393ff8d10a1a85615b33a1a82a7d59b8..ee0df8db4a0b125f5105dcf8ee954a9a2fd92212 100644
--- a/1.0.4.html
+++ b/1.0.4.html
@@ -398,50 +398,60 @@
 
     const sendCommand = async (deviceType, command) => {
       let device, endpointOut;
       if (deviceType === 'tx') {
         device = txDevice;
         endpointOut = txEndpointOut;
       } else if (deviceType === 'rx') {
         device = rxDevice;
         endpointOut = rxEndpointOut;
       } else {
         return;
       }
 
       if (!device) {
         return;
       }
       try {
         await device.transferOut(endpointOut, textEncoder.encode(command + '\n'));
       } catch (error) {
         console.error(`Send command to ${deviceType.toUpperCase()} error:`, error);
         log(`Error sending command to ${deviceType.toUpperCase()}: ${error.message}`);
         setConnectionStatus(deviceType, false);
       }
     };
 
+    const sendTxCommand = async (command) => {
+      if (txDevice) {
+        return sendCommand('tx', command);
+      }
+      if (rxDevice) {
+        return sendCommand('rx', command);
+      }
+      log("No TX or RX device connected to send command.");
+    };
+
     const sendChannelToRX = async (channel) => {
         if (!rxDevice) {
             log("RX device not connected. Cannot send channel.");
             return;
         }
         try {
             const data = new Uint8Array([0x43, channel]); // 0x43 is ASCII for 'C'
             await rxDevice.transferOut(rxEndpointOut, data);
             log(`Sent RX ESB Channel: ${channel}`);
         } catch (error) {
             console.error("Send channel to RX error:", error);
             log(`Error sending channel to RX: ${error.message}`);
             setConnectionStatus('rx', false);
         }
     };
 
     const populateTxUI = (settings) => {
       currentTxSettingsCache = settings;
 
       // Bank Selection
       bankSelectionGrid.innerHTML = '';
       for (let i = 0; i < 12; i++) {
         const bankBtn = document.createElement('button');
         bankBtn.className = 'bank-btn p-3 text-sm font-semibold rounded-lg bg-slate-800 hover:bg-slate-700/70 transition-colors duration-150 transform hover:scale-105 active:scale-95 shadow-md';
         bankBtn.textContent = `${i + 1}`;
@@ -583,67 +593,69 @@
         keepReadingFlag = () => txKeepReading;
       } else if (deviceType === 'rx') {
         device = rxDevice;
         endpointIn = rxEndpointIn;
         keepReadingFlag = () => rxKeepReading;
       } else {
         return;
       }
 
       let incomingData = "";
       while (keepReadingFlag()) {
         try {
           let result = await device.transferIn(endpointIn, 512);
           if (result.status === 'ok' && result.data.byteLength > 0) {
             incomingData += textDecoder.decode(result.data, { stream: true });
             let newlineIndex;
             while ((newlineIndex = incomingData.indexOf('\n')) !== -1) {
               const line = incomingData.slice(0, newlineIndex).trim();
               incomingData = incomingData.slice(newlineIndex + 1);
               if (line.startsWith('{')) {
                 try {
                   const parsedJson = JSON.parse(line);
                   if (deviceType === 'tx') {
                     populateTxUI(parsedJson);
                   } else if (deviceType === 'rx') {
-                    if (parsedJson.rssi !== undefined) {
+                    if (parsedJson.activeBank !== undefined) {
+                      populateTxUI(parsedJson);
+                    } else if (parsedJson.rssi !== undefined) {
                       updateRxRSSI(parsedJson.rssi);
                     } else {
                       populateRxUI(parsedJson);
                     }
                   }
                 } catch (e) {
                   log(`JSON Parse Error (${deviceType.toUpperCase()}): ${e.message}`);
                 }
               } else if (line.startsWith('cc:')) {
                 if (deviceType === 'tx') {
                   const parts = line.substring(3).split(',');
                   if (parts.length === 2) updateCCVisualizer(parseInt(parts[0]), parseInt(parts[1]));
                 }
               } else if (line.startsWith('bank_changed:')) {
-                if (deviceType === 'tx') {
-                  setTimeout(() => sendCommand('tx', 'get_settings'), 100);
+                if (deviceType === 'tx' || deviceType === 'rx') {
+                  setTimeout(() => sendTxCommand('get_settings'), 100);
                 }
               }
             }
           }
         } catch (error) {
           if (error.message.includes("disconnected")) {
             log(`${deviceType.toUpperCase()} device disconnected.`);
             setConnectionStatus(deviceType, false);
           } else {
             log(`Read loop error (${deviceType.toUpperCase()}): ${error.message}`);
           }
           if (deviceType === 'tx') txKeepReading = false;
           else if (deviceType === 'rx') rxKeepReading = false;
           break;
         }
       }
     }
 
     // Modified connectDevice function to support both initial request and auto-reconnect
     const connectDevice = async (deviceType, vendorId, productId, deviceToConnect = null) => {
       let deviceObj, interfaceNum, endpointInNum, endpointOutNum;
       let connectionStatusEl = deviceType === 'tx' ? txConnectionStatusEl : rxConnectionStatusElCol;
       let deviceRef = deviceType === 'tx' ? txDevice : rxDevice;
       let keepReadingRef = deviceType === 'tx' ? txKeepReading : rxKeepReading;
 
@@ -679,59 +691,60 @@
             if (alt.interfaceClass === 0xFF) { // Assuming a vendor-specific class
               interfaceNum = iface.interfaceNumber;
               for (const ep of alt.endpoints) {
                 if (ep.direction === 'out') endpointOutNum = ep.endpointNumber;
                 if (ep.direction === 'in') endpointInNum = ep.endpointNumber;
               }
             }
           }
         }
         if (interfaceNum === undefined) throw new Error("Interface not found for the selected device.");
 
         await deviceObj.claimInterface(interfaceNum);
         await deviceObj.controlTransferOut({ requestType: 'class', recipient: 'interface', request: 0x22, value: 0x01, index: interfaceNum });
 
         log(`${deviceType.toUpperCase()} device connected successfully!`);
         setConnectionStatus(deviceType, true);
 
         if (deviceType === 'tx') {
           txDevice = deviceObj;
           txInterfaceNumber = interfaceNum;
           txEndpointIn = endpointInNum;
           txEndpointOut = endpointOutNum;
           txKeepReading = true;
           txWasConnected = true;
           readLoop('tx');
-          await sendCommand('tx', "get_settings");
+          await sendTxCommand("get_settings");
         } else if (deviceType === 'rx') {
           rxDevice = deviceObj;
           rxInterfaceNumber = interfaceNum;
           rxEndpointIn = endpointInNum;
           rxEndpointOut = endpointOutNum;
           rxKeepReading = true;
           rxWasConnected = true;
           readLoop('rx');
+          await sendTxCommand("get_settings");
           // Start polling for RSSI after successful connection
           if (rxRssiInterval) clearInterval(rxRssiInterval);
           rxRssiInterval = setInterval(() => {
               if (rxDevice && rxDevice.opened) {
                   sendCommand('rx', 'R'); // 'R' for Request RSSI
               }
           }, 50);
         }
         return true;
       } catch (error) {
         if (error.message.includes("User cancelled") || error.message.includes("No device selected")) {
           log(`Connection for ${deviceType.toUpperCase()} cancelled by user.`);
         } else if (!(deviceRef && error.message.includes("disconnected"))) {
           log(`Connection failed for ${deviceType.toUpperCase()}: ${error.message}`);
         }
 
         if (deviceRef && error.message.includes("disconnected")) {
           if (deviceType === 'tx') txDevice = null;
           else if (deviceType === 'rx') rxDevice = null;
         }
 
         setConnectionStatus(deviceType, false);
         return false;
       } finally {
         updateButtonStates();
@@ -876,76 +889,76 @@
     connectRxButton.addEventListener('click', async () => {
       await connectDevice('rx', RX_VID, RX_PID); // Trigger requestDevice for initial connection
       startAutoReconnect(); // Restart auto-reconnect after manual connection
     });
 
     disconnectTxButton.addEventListener('click', () => disconnectDevice('tx'));
     disconnectRxButton.addEventListener('click', () => disconnectDevice('rx')); // Use the correct button ID for RX
 
     document.addEventListener('input', (e) => {
       const target = e.target;
       if (target.id === 'brightness') brightnessValueEl.textContent = target.value;
       else if (target.id === 'midiChannel') midiChannelValueEl.textContent = target.value;
       else if (target.id === 'esbChannel') esbChannelValueEl.textContent = target.value;
       else if (target.id === 'rxEsbChannel-col') rxEsbChannelValueElCol.textContent = target.value;
     });
 
     // The 'change' event listener is now responsible for sending commands
     // when a control's value is finalized (e.g., mouse release for sliders)
     document.addEventListener('change', (e) => {
       const t = e.target;
       const action = t.dataset.action;
       const deviceType = t.closest('#main-controls-tx') ? 'tx' : 'rx';
 
       if (deviceType === 'tx') {
         let cmd = `set_${action}=${t.dataset.index ? t.dataset.index + ',' : ''}${t.value}`;
-        sendCommand('tx', cmd);
-        if (action === 'cc' || action === 'label') setTimeout(() => sendCommand('tx', 'get_settings'), 200);
+        sendTxCommand(cmd);
+        if (action === 'cc' || action === 'label') setTimeout(() => sendTxCommand('get_settings'), 200);
       } else if (deviceType === 'rx' && action === 'rx_esb_ch') {
         // Snap RX ESB Channel value to the nearest 5
         const rawValue = parseInt(t.value);
         const snappedValue = Math.round(rawValue / 5) * 5;
         t.value = snappedValue; // Update slider position
         rxEsbChannelValueElCol.textContent = snappedValue; // Update display
         
         // Send the single command to set the channel on release
         sendChannelToRX(snappedValue);
       }
     });
 
     document.addEventListener('click', (e) => {
       const target = e.target.closest('button');
       if (!target) return;
 
       if (target.classList.contains('bank-btn')) {
         document.querySelectorAll('.bank-btn').forEach(btn => btn.classList.remove('active'));
         target.classList.add('active');
-        sendCommand('tx', `set_bank=${target.dataset.bank}`);
+        sendTxCommand(`set_bank=${target.dataset.bank}`);
       } else if (target.id === 'bleToggleButton') {
-        sendCommand('tx', 'toggle_ble');
+        sendTxCommand('toggle_ble');
       } else if (target.id === 'startCalButton') {
-        sendCommand('tx', 'start_cal');
+        sendTxCommand('start_cal');
         log("Calibration started. Follow device instructions.");
       }
     });
 
     // Initial setup on window load
     window.onload = () => {
       updateButtonStates(); // Set initial button states
       updateUIVisibility(); // Set initial UI visibility
       startAutoReconnect(); // Start the alternating auto-reconnect loop
     };
 
     // USB device connect/disconnect event listeners for the browser
     navigator.usb.addEventListener('connect', (event) => {
       const device = event.device;
       log(`USB Device connected: ${device.productName} (VID: 0x${device.vendorId.toString(16)}, PID: 0x${device.productId.toString(16)})`);
       // Attempt to connect newly connected device if it matches our VIDs/PIDs
       if (device.vendorId === TX_VID && device.productId === TX_PID) {
         connectDevice('tx', TX_VID, TX_PID, device);
       } else if (device.vendorId === RX_VID && device.productId === RX_PID) {
         connectDevice('rx', RX_VID, RX_PID, device);
       }
       startAutoReconnect(); // Restart auto-reconnect on any USB connect event
     });
 
     navigator.usb.addEventListener('disconnect', (event) => {
@@ -956,26 +969,25 @@
         txKeepReading = false;
         txWasConnected = false;
         setConnectionStatus('tx', false);
       } else if (device.vendorId === RX_VID && device.productId === RX_PID) {
         if(rxRssiInterval) {
             clearInterval(rxRssiInterval);
             rxRssiInterval = null;
         }
         rxDevice = null;
         rxKeepReading = false;
         rxWasConnected = false;
         setConnectionStatus('rx', false);
         rxEsbChannelSliderCol.value = 0;
         rxEsbChannelValueElCol.textContent = '';
         rxRssiValueElCol.textContent = '-- dBm';
         verticalRssiBar.style.height = '0%';
       }
       updateButtonStates();
       updateUIVisibility();
       startAutoReconnect(); // Always restart auto-reconnect
     });
 
   </script>
 </body>
 </html>
-
